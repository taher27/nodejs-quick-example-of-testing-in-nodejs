// ********RoostGPT********
/*
Test generated by RoostGPT for test testJ using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=fetchWeather_e15d09d035
ROOST_METHOD_SIG_HASH=fetchWeather_2ec6f97b3f


*/

// ********RoostGPT********
const request = require('request');
const fetchWeather = require('../weather/fetch-weather');

jest.mock('request');

describe('fetchWeather', () => {
  beforeEach(() => {
    request.mockClear();
  });

  test('should process results correctly when request is successful', () => {
    const mockLocation = 'London';
    const mockResponse = {
      statusCode: 200,
      body: {
        weather: [
          {
            main: 'Clear',
            description: 'clear sky',
          },
        ],
        main: {
          temp: 289.5,
          feels_like: 286.13,
        },
      },
    };

    request.mockImplementation((_, callback) => {
      callback(null, mockResponse, mockResponse.body);
    });

    const mockCallback = jest.fn();

    fetchWeather(mockLocation, mockCallback);

    expect(request).toHaveBeenCalledWith(
      expect.objectContaining({
        url: expect.stringContaining(mockLocation),
      }),
      expect.any(Function),
    );

    expect(mockCallback).toHaveBeenCalledWith(mockResponse.body);
  });

  test('should handle error correctly when request fails', () => {
    const mockLocation = 'London';
    const mockError = new Error('Request failed');

    request.mockImplementation((_, callback) => {
      callback(mockError, null, null);
    });

    const mockCallback = jest.fn();

    fetchWeather(mockLocation, mockCallback);

    expect(request).toHaveBeenCalledWith(
      expect.objectContaining({
        url: expect.stringContaining(mockLocation),
      }),
      expect.any(Function),
    );

    expect(mockCallback).not.toHaveBeenCalled();
  });
});
